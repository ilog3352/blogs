import{_ as a,c as t,o as l,ag as r}from"./chunks/framework.DuJzXpJq.js";const s=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"everything/vue/vue原理.md","filePath":"everything/vue/vue原理.md","lastUpdated":null}'),i={name:"everything/vue/vue原理.md"};function o(p,e,u,d,c,h){return l(),t("div",null,e[0]||(e[0]=[r('<h2 id="响应式原理reactive" tabindex="-1">响应式原理reactive <a class="header-anchor" href="#响应式原理reactive" aria-label="Permalink to &quot;响应式原理reactive&quot;">​</a></h2><p>通过proxy，Reflect拦截取值赋值的操作,通过tracker收集依赖，trigger更新依赖，数据结构是一个weakMap，weakMap的key是对象本身，value是一个map结构，map的key是对象要操作的key，value是一个set结构，set结构里放的是通过effect收集的具体方法。当更新的时候调用trigger方法，拿到set，遍历重新执行一边。就更新了。</p><h4 id="为什么使用weakmap" tabindex="-1">为什么使用weakMap <a class="header-anchor" href="#为什么使用weakmap" aria-label="Permalink to &quot;为什么使用weakMap&quot;">​</a></h4><p>可能会有手动释放的情况，不会因为被使用影响垃圾回收</p><h4 id="副作用函数" tabindex="-1">副作用函数 <a class="header-anchor" href="#副作用函数" aria-label="Permalink to &quot;副作用函数&quot;">​</a></h4><p>副作用函数：外部修改函数内部引用的变量会影响函数内部 ;纯函数 :不受影响</p><h2 id="computed原理" tabindex="-1">computed原理 <a class="header-anchor" href="#computed原理" aria-label="Permalink to &quot;computed原理&quot;">​</a></h2><p>computed接收一个getter函数，函数内部也是调用了effect函数，只是需要一个返回值，effect函数把传进来具体操作对象的方法返回，然后在computed方法内部实现了一个类，声明了get value方法内部调用了具体操作对象的函数，然后把类return出去 在.value的时候就更新依赖，防止首次调用是传了一个配置项，传了一个lazy，跟scheduler做缓存， 生命一个dirty为true，为true就重新更新依赖然后设为false，当依赖改变的时候出发tigger调用scheduler再次设为true，判断是在.value里边判断的</p><h2 id="watch原理" tabindex="-1">watch原理 <a class="header-anchor" href="#watch原理" aria-label="Permalink to &quot;watch原理&quot;">​</a></h2><p>watch 可以接收三个参数，第一个参数是要监听的对象，第二个参数是回调函数，第三个参数是一个配置项 imdt 深度监听 flush</p><p>内部原理：</p><ol><li><p>格式化参数，格式化成get函数</p></li><li><p>返回值 （跟computed很像）也是需要effect函数 传入lazy scheduler 当依赖发生变化调用scheduler</p><ol><li><p>​ newValue = effectFn()</p><p>​ cb(newValue, oldValue)</p><p>​ oldValue = newValue</p></li></ol></li></ol><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h2><p>虚拟DOM就是通过js生成的ast语法树，ast是抽象语法树，为什么用？很多语言都会使用这个东西，比如TS-&gt;JS、babel ES6 -&gt; ES5</p><p>为什么不直接操作dom：浪费性能，dom属性非常多，操作js非常快就有了虚拟dom这个概念，还可以做算法优化比如有很多dom可以复用，Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，也就是v-for，在v-for更新的时候，有key的diff算法跟没有key的diff不一样</p><p>没有key 三步骤</p><ol><li>替换 直接替换</li><li>新增 有多的就新增</li><li>删除 有少的就删除</li></ol><p>有key 五步骤</p><ol><li>前序算法 前边开始对比 不一样退出</li><li>尾序对比 尾部开始对比 不一样退出</li><li>新增</li><li>删除</li><li>乱序对比 算什么最长递增子序列算法</li></ol><h2 id="vue3为什么换到proxy" tabindex="-1">vue3为什么换到proxy <a class="header-anchor" href="#vue3为什么换到proxy" aria-label="Permalink to &quot;vue3为什么换到proxy&quot;">​</a></h2><p>vue2使用的是Object.defineProperty,vue3使用的是proxy</p><p>因为vue2的object.difineProperty有很多不足，</p><ol><li><p>数组的API拦截不到（性能消耗过大）数组属性太多</p></li><li><p>对象新增的属性不能拦截</p></li><li><p>通过length修改数组拦截不到（通过$SET)</p><p>$set原理：</p><ol><li>判断是否是响应式对象<code>__observer__</code> 是的话直接返回</li><li>判断是否是对象 是对象key[value]方式修改值 如果是新的属性就增加变成响应式的</li><li>数组，调用splice方法修改值</li><li>视图更新，通过dep.notify</li></ol></li></ol><p>通过proxy代理对象，通过getter，setter，delete等方法劫持对象的增删改查，发生变化通过effect函数来更新依赖</p><h2 id="计算属性原理" tabindex="-1">计算属性原理 <a class="header-anchor" href="#计算属性原理" aria-label="Permalink to &quot;计算属性原理&quot;">​</a></h2><p>两种参数模式，先初始化参数，函数模式不允许设置值，</p><p>内部采用脏值检测的模式，使用class实现的</p><p>默认dirty为true，主要就是判断dirty是否为true，true就更新一下数据并设置为false，false就拿缓存的值，当依赖发生变化设置为true</p><h2 id="vite为什么快" tabindex="-1">vite为什么快 <a class="header-anchor" href="#vite为什么快" aria-label="Permalink to &quot;vite为什么快&quot;">​</a></h2><p>不会打包，webpack会打包，vite利用了浏览器esmodule，在index.html加了一个type=“module”，会发送一个请求，拦截app.vue文件 把vue代码转换为浏览器可识别的语音，template转换为render函数，setup转换为setup函数</p><h2 id="vue3-vue2区别" tabindex="-1">vue3 vue2区别 <a class="header-anchor" href="#vue3-vue2区别" aria-label="Permalink to &quot;vue3 vue2区别&quot;">​</a></h2><p>vue3 动态标记 体现在 template 编译后的render函数里 ast -&gt; transform -&gt; generate -&gt; render</p>',32)]))}const v=a(i,[["render",o]]);export{s as __pageData,v as default};
